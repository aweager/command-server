#!/bin/zsh

zmodload zsh/zutil
zmodload zsh/net/socket
zmodload -F zsh/stat b:zstat

function call-command-server() {
    setopt local_options local_traps err_return

    local -a fifos
    local -a pids
    local send_fd
    local request_id

    () {
        private -a arg_background
        zparseopts -D -- \
            {b,-background}=arg_background

        private backgrounded=""
        if [[ -n $arg_background ]]; then
            backgrounded=1
        else
            trap '
                if [[ -n "$request_id" ]]; then
                    printf "%s\\0" sig "$request_id" INT >&$send_fd
                fi
            ' INT
            trap '
                if [[ -n "$request_id" ]]; then
                    printf "%s\\0" sig "$request_id" TERM
                fi
            ' TERM
            trap '
                if [[ -n "$request_id" ]]; then
                    printf "%s\\0" sig "$request_id" QUIT
                fi
            ' QUIT
            trap '
                if [[ -n "$request_id" ]]; then
                    printf "%s\\0" sig "$request_id" HUP
                fi
            ' HUP
        fi

        trap '
            local pid
            for pid in "$pids[@]"; do
                kill -HUP "$pid" &> /dev/null || true
            done

            local fifo
            for fifo in "$fifos[@]"; do
                if [[ -e $fifo ]]; then
                    rm "$fifo"
                fi
            done

            if [[ -n "$send_fd" ]]; then
                exec {send_fd}>&-
            fi
        ' EXIT

        local socket="$1"
        zsocket "$socket"
        send_fd="$REPLY"
        shift

        local stdin stdout stderr receive

        if [[ -t 0 && -z $backgrounded ]]; then
            # need to use $(tty) instead of $TTY because we need whatever is hooked
            # up to fd 0, not what this shell started with
            stdin="$(tty)"
        elif [[ -z $backgrounded ]]; then
            stdin="$(mktemp -u)"
            socat -u FD:0 "PIPE:$stdin" &> /dev/null &
            pids+=("$!")
        else
            stdin=/dev/null
        fi

        if [[ -n $backgrounded ]]; then
            stdout=/dev/null
            stderr=/dev/null
            receive=/dev/null
        else
            stdout="$(mktemp -u)"
            socat -U FD:1 "PIPE:$stdout,ignoreeof" 2> /dev/null &
            pids+=("$!")

            # If stdout and stderr are the same, don't separate them here.
            # This allows us to maintain line order writing to the terminal
            local -A OutStat
            zstat -H OutStat -f 1
            local -A ErrStat
            zstat -H ErrStat -f 2
            if [[ "$OutStat[inode]" == "$ErrStat[inode]" && "$OutStat[rdev]" == "$ErrStat[rdev]" ]]; then
                stderr="$stdout"
            else
                stderr="$(mktemp -u)"
                socat -U FD:2 "PIPE:$stderr,ignoreeof" 2> /dev/null &
                pids+=("$!")
            fi

            # FIFO for receiving $? from the server
            receive="$(mktemp -u)"
            fifos+=("$receive")
            mkfifo -m 600 "$receive"
        fi

        local -a quoted_command=("${(@q+)*}")
        local -a request=(
            "call"
            "$PWD"
            "$stdin"
            "$stdout"
            "$stderr"
            "$receive"
            "$quoted_command[*]"
        )

        local request_id

        printf '%s\0' "${request[@]}" >&$send_fd

        IFS="" read request_id < "$receive"

        if [[ -n $backgrounded ]]; then
            return 0
        else
            local result
            IFS="" read result < "$receive"
            return $result
        fi
    } "$@"
}

call-command-server "$@"
